-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParInterpreter where
import AbsInterpreter
import LexInterpreter
import ErrM

}

%name pProgram Program
%name pProgramHeader ProgramHeader
%name pDeclarations Declarations
%name pVariableDeclarations VariableDeclarations
%name pVariableDeclarationList VariableDeclarationList
%name pVarDec VarDec
%name pProcedureDeclarations ProcedureDeclarations
%name pProcDec ProcDec
%name pProcHeader ProcHeader
%name pFuncHeader FuncHeader
%name pArguments Arguments
%name pArgumentList ArgumentList
%name pArg Arg
%name pCompoundStatement CompoundStatement
%name pStatementList StatementList
%name pStatement Statement
%name pAssignmentStatement AssignmentStatement
%name pProcedureCall ProcedureCall
%name pForStatement ForStatement
%name pWhileStatement WhileStatement
%name pIfStatement IfStatement
%name pPrintStatement PrintStatement
%name pExpression Expression
%name pSimpleExpression SimpleExpression
%name pTerm Term
%name pFactor Factor
%name pFunctionCall FunctionCall
%name pActuals Actuals
%name pExpressionList ExpressionList
%name pIdList IdList
%name pTypeSpecifier TypeSpecifier
%name pDimensionList DimensionList
%name pConstant Constant
%name pBoolean Boolean
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '.' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '<=' { PT _ (TS _ 13) }
  '<>' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  ']' { PT _ (TS _ 19) }
  'array' { PT _ (TS _ 20) }
  'begin' { PT _ (TS _ 21) }
  'bool' { PT _ (TS _ 22) }
  'do' { PT _ (TS _ 23) }
  'else' { PT _ (TS _ 24) }
  'end' { PT _ (TS _ 25) }
  'endif' { PT _ (TS _ 26) }
  'false' { PT _ (TS _ 27) }
  'for' { PT _ (TS _ 28) }
  'function' { PT _ (TS _ 29) }
  'if' { PT _ (TS _ 30) }
  'int' { PT _ (TS _ 31) }
  'int_to_string' { PT _ (TS _ 32) }
  'of' { PT _ (TS _ 33) }
  'print' { PT _ (TS _ 34) }
  'procedure' { PT _ (TS _ 35) }
  'program' { PT _ (TS _ 36) }
  'string' { PT _ (TS _ 37) }
  'string_to_int' { PT _ (TS _ 38) }
  'then' { PT _ (TS _ 39) }
  'to' { PT _ (TS _ 40) }
  'true' { PT _ (TS _ 41) }
  'var' { PT _ (TS _ 42) }
  'while' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ProgramHeader Declarations CompoundStatement '.' { AbsInterpreter.Prog $1 $2 $3 }
ProgramHeader :: { ProgramHeader }
ProgramHeader : 'program' Ident ';' { AbsInterpreter.ProgHead $2 }
Declarations :: { Declarations }
Declarations : VariableDeclarations ProcedureDeclarations { AbsInterpreter.Dec $1 $2 }
VariableDeclarations :: { VariableDeclarations }
VariableDeclarations : {- empty -} { AbsInterpreter.VarDecEmpty }
                     | 'var' VariableDeclarationList { AbsInterpreter.VarDecFull $2 }
VariableDeclarationList :: { VariableDeclarationList }
VariableDeclarationList : VarDec { AbsInterpreter.VarDecListEnd $1 }
                        | VarDec VariableDeclarationList { AbsInterpreter.VarDecList $1 $2 }
VarDec :: { VarDec }
VarDec : IdList ':' TypeSpecifier ';' { AbsInterpreter.VarDecLabel $1 $3 }
ProcedureDeclarations :: { ProcedureDeclarations }
ProcedureDeclarations : {- empty -} { AbsInterpreter.ProcDecEmpty }
                      | ProcDec ProcedureDeclarations { AbsInterpreter.ProcDecLabel $1 $2 }
ProcDec :: { ProcDec }
ProcDec : ProcHeader Declarations CompoundStatement ';' { AbsInterpreter.ProcDecProc $1 $2 $3 }
        | FuncHeader Declarations CompoundStatement ';' { AbsInterpreter.ProcDecFun $1 $2 $3 }
ProcHeader :: { ProcHeader }
ProcHeader : 'procedure' Ident Arguments ';' { AbsInterpreter.ProcHead $2 $3 }
FuncHeader :: { FuncHeader }
FuncHeader : 'function' Ident Arguments ':' TypeSpecifier ';' { AbsInterpreter.FunHead $2 $3 $5 }
Arguments :: { Arguments }
Arguments : '(' ')' { AbsInterpreter.ArgsEmpty }
          | '(' ArgumentList ')' { AbsInterpreter.Args $2 }
ArgumentList :: { ArgumentList }
ArgumentList : Arg { AbsInterpreter.ArgListOne $1 }
             | Arg ';' ArgumentList { AbsInterpreter.ArgList $1 $3 }
Arg :: { Arg }
Arg : IdList ':' TypeSpecifier { AbsInterpreter.ArgLabel $1 $3 }
CompoundStatement :: { CompoundStatement }
CompoundStatement : 'begin' StatementList 'end' { AbsInterpreter.CompStmnt $2 }
StatementList :: { StatementList }
StatementList : {- empty -} { AbsInterpreter.StmntListEmpty }
              | Statement ';' StatementList { AbsInterpreter.StmntList $1 $3 }
Statement :: { Statement }
Statement : {- empty -} { AbsInterpreter.SEmpty }
          | CompoundStatement { AbsInterpreter.SComp $1 }
          | AssignmentStatement { AbsInterpreter.SAss $1 }
          | ProcedureCall { AbsInterpreter.SProc $1 }
          | ForStatement { AbsInterpreter.SFor $1 }
          | WhileStatement { AbsInterpreter.SWhile $1 }
          | IfStatement { AbsInterpreter.SIf $1 }
          | PrintStatement { AbsInterpreter.SPrint $1 }
AssignmentStatement :: { AssignmentStatement }
AssignmentStatement : Ident ':=' Expression { AbsInterpreter.AssStmnt $1 $3 }
                    | Ident '[' ExpressionList ']' ':=' Expression { AbsInterpreter.AssStmntArr $1 $3 $6 }
ProcedureCall :: { ProcedureCall }
ProcedureCall : Ident Actuals { AbsInterpreter.ProcCall $1 $2 }
ForStatement :: { ForStatement }
ForStatement : 'for' Ident ':=' Expression 'to' Expression 'do' Statement { AbsInterpreter.ForStmnt $2 $4 $6 $8 }
WhileStatement :: { WhileStatement }
WhileStatement : 'while' Expression 'do' Statement { AbsInterpreter.WhileStmnt $2 $4 }
IfStatement :: { IfStatement }
IfStatement : 'if' Expression 'then' Statement 'endif' { AbsInterpreter.IfStmnt $2 $4 }
            | 'if' Expression 'then' Statement 'else' Statement 'endif' { AbsInterpreter.IfStmntWithElse $2 $4 $6 }
PrintStatement :: { PrintStatement }
PrintStatement : 'print' Expression { AbsInterpreter.PrintStmnt $2 }
Expression :: { Expression }
Expression : SimpleExpression { AbsInterpreter.ExpSimple $1 }
           | SimpleExpression '=' SimpleExpression { AbsInterpreter.ExpEqual $1 $3 }
           | SimpleExpression '<>' SimpleExpression { AbsInterpreter.ExpNotEqual $1 $3 }
           | SimpleExpression '<' SimpleExpression { AbsInterpreter.ExpLess $1 $3 }
           | SimpleExpression '<=' SimpleExpression { AbsInterpreter.ExpLessOrEqual $1 $3 }
           | SimpleExpression '>' SimpleExpression { AbsInterpreter.ExpGreater $1 $3 }
           | SimpleExpression '>=' SimpleExpression { AbsInterpreter.ExpGreaterOrEqual $1 $3 }
SimpleExpression :: { SimpleExpression }
SimpleExpression : Term { AbsInterpreter.SimpleExpTerm $1 }
                 | SimpleExpression '+' Term { AbsInterpreter.SimpleExpAdd $1 $3 }
                 | SimpleExpression '-' Term { AbsInterpreter.SimpleExpSubst $1 $3 }
Term :: { Term }
Term : Factor { AbsInterpreter.TermFactor $1 }
     | Term '*' Factor { AbsInterpreter.TermMultiply $1 $3 }
     | Term '/' Factor { AbsInterpreter.TermDivide $1 $3 }
Factor :: { Factor }
Factor : '(' Expression ')' { AbsInterpreter.FactorExpression $2 }
       | '+' Factor { AbsInterpreter.FactorPlus $2 }
       | '-' Factor { AbsInterpreter.FactorMinus $2 }
       | FunctionCall { AbsInterpreter.FactorFunctionCall $1 }
       | Constant { AbsInterpreter.FactorConstant $1 }
       | Ident { AbsInterpreter.FactorIdent $1 }
       | Ident '[' ExpressionList ']' { AbsInterpreter.FactorArray $1 $3 }
       | 'string_to_int' '(' Expression ')' { AbsInterpreter.FactorStoI $3 }
       | 'int_to_string' '(' Expression ')' { AbsInterpreter.FactorItoS $3 }
FunctionCall :: { FunctionCall }
FunctionCall : Ident Actuals { AbsInterpreter.FunsCall $1 $2 }
Actuals :: { Actuals }
Actuals : '(' ')' { AbsInterpreter.ActEmpty }
        | '(' ExpressionList ')' { AbsInterpreter.Act $2 }
ExpressionList :: { ExpressionList }
ExpressionList : Expression { AbsInterpreter.ExpListOne $1 }
               | Expression ',' ExpressionList { AbsInterpreter.ExpList $1 $3 }
IdList :: { IdList }
IdList : Ident { AbsInterpreter.IdLEnd $1 }
       | Ident ',' IdList { AbsInterpreter.IdL $1 $3 }
TypeSpecifier :: { TypeSpecifier }
TypeSpecifier : 'int' { AbsInterpreter.TypeSpecInt }
              | 'bool' { AbsInterpreter.TypeSpecBool }
              | 'string' { AbsInterpreter.TypeSpecString }
              | 'array' '[' DimensionList ']' 'of' TypeSpecifier { AbsInterpreter.TypeSpecArray $3 $6 }
DimensionList :: { DimensionList }
DimensionList : Integer { AbsInterpreter.DimListEnd $1 }
              | Integer ',' DimensionList { AbsInterpreter.DimList $1 $3 }
Constant :: { Constant }
Constant : Integer { AbsInterpreter.ConstInt $1 }
         | Boolean { AbsInterpreter.ConstBool $1 }
         | String { AbsInterpreter.ConstString $1 }
Boolean :: { Boolean }
Boolean : 'true' { AbsInterpreter.BoolTrue }
        | 'false' { AbsInterpreter.BoolFalse }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

